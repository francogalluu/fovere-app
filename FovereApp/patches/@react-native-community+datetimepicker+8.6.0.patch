diff --git a/ios/RNDateTimePicker.m b/ios/RNDateTimePicker.m
index 1234567..abcdefg 100644
--- a/ios/RNDateTimePicker.m
+++ b/ios/RNDateTimePicker.m
@@ -40,11 +40,21 @@ RCT_NOT_IMPLEMENTED(- (instancetype)initWithCoder:(NSCoder *)aDecoder)
 
 - (void)didChange
 {
   if (_onChange) {
-    _onChange(@{ @"timestamp": @(self.date.timeIntervalSince1970 * 1000.0), @"utcOffset": @([self.timeZone secondsFromGMTForDate:self.date] / 60 )});
+    double timestamp;
+    if (self.datePickerMode == UIDatePickerModeCountDownTimer) {
+      // In countdown mode, send duration in milliseconds (JS will use timestamp/60000 for minutes).
+      timestamp = self.countDownDuration * 1000.0;
+    } else {
+      timestamp = self.date.timeIntervalSince1970 * 1000.0;
+    }
+    _onChange(@{ @"timestamp": @(timestamp), @"utcOffset": @([self.timeZone secondsFromGMTForDate:self.date] / 60 )});
   }
 }
 
 - (void)onDismiss:(RNDateTimePicker *)sender
@@ -66,7 +76,15 @@ - (void)setMinuteInterval:(NSInteger)minuteInterval
 }
 
 - (void)setDate:(NSDate *)date {
-    // Need to avoid the case where values coming back through the bridge trigger a new valueChanged event
+    if (self.datePickerMode == UIDatePickerModeCountDownTimer && date != nil) {
+        // In countdown mode, set countDownDuration (seconds). JS sends reference date + duration.
+        static NSTimeInterval kCountDownReference1970 = 978307200.0; // 2001-01-01 00:00 UTC
+        NSTimeInterval duration = [date timeIntervalSince1970] - kCountDownReference1970;
+        if (duration >= 0) {
+            self.countDownDuration = duration;
+        }
+        return;
+    }
+    // Need to avoid the case where values coming back through the bridge trigger a new valueChanged event
     if (![self.date isEqualToDate:date]) {
         [super setDate:date animated:NO];
     }
